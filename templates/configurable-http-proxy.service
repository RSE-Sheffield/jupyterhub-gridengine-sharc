# vi:syntax=systemd
[Unit]
Description=configurable-http-proxy
Documentation=https://github.com/jupyterhub/configurable-http-proxy
After=syslog.target network.target

[Service]
# The process configured with ExecStart= is the main process of the service
Type=simple

# Set the UNIX user or group that the processes are executed as
User=chproxy
Group=chproxy

#ExecStartPre=
ExecStart=/usr/bin/configurable-http-proxy \
    <% if @chproxy_pub_ip != "all" -%>--ip=<%= @chproxy_pub_ip -%><% end %> \
    --port=<%= @chproxy_pub_port -%> \
    --api-ip=<%= @chproxy_api_ip -%> \
    --api-port=<%= @chproxy_api_port -%> \
    --default-target=http://<%= @chproxy_default_target_host -%>:<%= @chproxy_default_target_port -%> \
    --error-target=http://<%= @chproxy_default_target_host -%>:<%= @chproxy_default_target_port -%>/hub/error
Restart=no
#ExecStop=
#ExecReload=

# Environment variables for executed processes
Environment="CONFIGPROXY_AUTH_TOKEN=<%= @chproxy_auth_token -%>"

ProtectSystem=yes

# Mount /usr, /boot and /etc read-only, except for the API file system
# subtrees /dev, /proc and /sys
#ProtectSystem=full

# Ideally we'd use 'ProtectHome=yes' to make /home, /root and /run/user inaccessible and
# empty to this service; however, qsub would then fail as it would annoyingly error when trying
# to read '$HOME/.sge_aliases'.  An alternative would be 'ProtectHome=read-only' but this
# prevents us from writing error logs to users' home directories.  We therefore need:
#ProtectHome=no

# Sets up a new file system namespace for the executed processes and mounts
# private /tmp and /var/tmp directories inside it that is not shared by
# processes outside of the namespace.  All temporary files created by a service
# in these directories will be removed after the service is stopped.
PrivateTmp=yes

[Install]
WantedBy=multi-user.target
